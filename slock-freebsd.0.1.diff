diff -ruN slock.org/config.def.h slock/config.def.h
--- slock.org/config.def.h	2023-05-17 13:30:04.572389000 +0200
+++ slock/config.def.h	2023-05-17 13:27:05.256468000 +0200
@@ -1,12 +1,38 @@
-/* user and group to drop privileges to */
-static const char *user  = "nobody";
-static const char *group = "nogroup";
-
 static const char *colorname[NUMCOLS] = {
-	[INIT] =   "black",     /* after initialization */
+    [BACKGROUND] = "white",
+	[INIT] =   "2d2d2d",     /* after initialization */
 	[INPUT] =  "#005577",   /* during input */
 	[FAILED] = "#CC3333",   /* wrong password */
+	[CAPS] = "yellow",         /* CapsLock on */
 };
 
 /* treat a cleared input like a wrong password (color) */
 static const int failonclear = 1;
+
+/* time in seconds before the monitor shuts down */
+static const int monitortime = 10;
+
+static const int logosize = 75;
+static const int logow = 12; /* Grid width and height for right center alignment*/
+static const int logoh = 6;
+
+static XRectangle rectangles[9] = {
+    {0, 3, 1, 3},
+    {1, 3, 2, 1},
+    {0, 5, 8, 1},
+    {3, 0, 1, 5},
+    {5, 3, 1, 2},
+    {7, 3, 1, 2},
+    {8, 3, 4, 1},
+    {9, 4, 1, 2},
+    {11,4, 1, 2},
+};
+
+/*Enable blur*/
+#define BLUR
+/*Set blur radius*/
+static const int blurRadius=5;
+/*Enable Pixelation*/
+//#define PIXELATION
+/*Set pixelation radius*/
+static const int pixelSize=0;
diff -ruN slock.org/config.h slock/config.h
--- slock.org/config.h	1970-01-01 01:00:00.000000000 +0100
+++ slock/config.h	2023-05-17 13:28:38.768901000 +0200
@@ -0,0 +1,38 @@
+static const char *colorname[NUMCOLS] = {
+    [BACKGROUND] = "white",
+	[INIT] =   "2d2d2d",     /* after initialization */
+	[INPUT] =  "#005577",   /* during input */
+	[FAILED] = "#CC3333",   /* wrong password */
+	[CAPS] = "yellow",         /* CapsLock on */
+};
+
+/* treat a cleared input like a wrong password (color) */
+static const int failonclear = 1;
+
+/* time in seconds before the monitor shuts down */
+static const int monitortime = 10;
+
+static const int logosize = 75;
+static const int logow = 12; /* Grid width and height for right center alignment*/
+static const int logoh = 6;
+
+static XRectangle rectangles[9] = {
+    {0, 3, 1, 3},
+    {1, 3, 2, 1},
+    {0, 5, 8, 1},
+    {3, 0, 1, 5},
+    {5, 3, 1, 2},
+    {7, 3, 1, 2},
+    {8, 3, 4, 1},
+    {9, 4, 1, 2},
+    {11,4, 1, 2},
+};
+
+/*Enable blur*/
+#define BLUR
+/*Set blur radius*/
+static const int blurRadius=5;
+/*Enable Pixelation*/
+//#define PIXELATION
+/*Set pixelation radius*/
+static const int pixelSize=0;
diff -ruN slock.org/config.mk slock/config.mk
--- slock.org/config.mk	2023-05-17 13:30:04.572562000 +0200
+++ slock/config.mk	2023-05-13 11:20:37.221903000 +0200
@@ -7,16 +7,24 @@
 PREFIX = /usr/local
 MANPREFIX = ${PREFIX}/share/man
 
-X11INC = /usr/X11R6/include
-X11LIB = /usr/X11R6/lib
+X11INC = /usr/local/include
+X11LIB = /usr/local/lib
 
+# Xinerama, comment if you don't want it
+XINERAMALIBS = -lXinerama
+XINERAMAFLAGS = -DXINERAMA
+
+# freetype
+FREETYPELIBS = -lXft
+FREETYPEINC = /usr/include/freetype2
+
 # includes and libs
-INCS = -I. -I/usr/include -I${X11INC}
-LIBS = -L/usr/lib -lc -lcrypt -L${X11LIB} -lX11 -lXext -lXrandr
+INCS = -I. -I/usr/include -I${X11INC} -I${FREETYPEINC}
+LIBS = -L/usr/lib -lc -lcrypt -L${X11LIB} -lX11 -lImlib2 ${XINERAMALIBS} ${FREETYPELIBS} -lXext -lXrandr
 
 # flags
-CPPFLAGS = -DVERSION=\"${VERSION}\" -D_DEFAULT_SOURCE -DHAVE_SHADOW_H
-CFLAGS = -std=c99 -pedantic -Wall -Os ${INCS} ${CPPFLAGS}
+CPPFLAGS = -DVERSION=\"${VERSION}\" -D_DEFAULT_SOURCE -DHAVE_PAM ${XINERAMAFLAGS}
+CFLAGS = -std=c99 -pedantic -Wall -Ofast ${INCS} ${CPPFLAGS}
 LDFLAGS = -s ${LIBS}
 COMPATSRC = explicit_bzero.c
 
diff -ruN slock.org/slock-freebsd.0.1.diff slock/slock-freebsd.0.1.diff
--- slock.org/slock-freebsd.0.1.diff	2023-05-17 13:32:23.925422000 +0200
+++ slock/slock-freebsd.0.1.diff	1970-01-01 01:00:00.000000000 +0100
@@ -1,1372 +0,0 @@
-diff -ruN slock.org/.git/HEAD slock/.git/HEAD
---- slock.org/.git/HEAD	2023-05-17 13:30:04.568906000 +0200
-+++ slock/.git/HEAD	1970-01-01 01:00:00.000000000 +0100
-@@ -1 +0,0 @@
--ref: refs/heads/master
-diff -ruN slock.org/.git/config slock/.git/config
---- slock.org/.git/config	2023-05-17 13:30:04.570653000 +0200
-+++ slock/.git/config	1970-01-01 01:00:00.000000000 +0100
-@@ -1,11 +0,0 @@
--[core]
--	repositoryformatversion = 0
--	filemode = true
--	bare = false
--	logallrefupdates = true
--[remote "origin"]
--	url = https://git.suckless.org/slock
--	fetch = +refs/heads/*:refs/remotes/origin/*
--[branch "master"]
--	remote = origin
--	merge = refs/heads/master
-diff -ruN slock.org/.git/description slock/.git/description
---- slock.org/.git/description	2023-05-17 13:30:03.855588000 +0200
-+++ slock/.git/description	1970-01-01 01:00:00.000000000 +0100
-@@ -1 +0,0 @@
--Unnamed repository; edit this file 'description' to name the repository.
-diff -ruN slock.org/.git/hooks/applypatch-msg.sample slock/.git/hooks/applypatch-msg.sample
---- slock.org/.git/hooks/applypatch-msg.sample	2023-05-17 13:30:03.857020000 +0200
-+++ slock/.git/hooks/applypatch-msg.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,15 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to check the commit log message taken by
--# applypatch from an e-mail message.
--#
--# The hook should exit with non-zero status after issuing an
--# appropriate message if it wants to stop the commit.  The hook is
--# allowed to edit the commit message file.
--#
--# To enable this hook, rename this file to "applypatch-msg".
--
--. git-sh-setup
--commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
--test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
--:
-diff -ruN slock.org/.git/hooks/commit-msg.sample slock/.git/hooks/commit-msg.sample
---- slock.org/.git/hooks/commit-msg.sample	2023-05-17 13:30:03.856885000 +0200
-+++ slock/.git/hooks/commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,24 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to check the commit log message.
--# Called by "git commit" with one argument, the name of the file
--# that has the commit message.  The hook should exit with non-zero
--# status after issuing an appropriate message if it wants to stop the
--# commit.  The hook is allowed to edit the commit message file.
--#
--# To enable this hook, rename this file to "commit-msg".
--
--# Uncomment the below to add a Signed-off-by line to the message.
--# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
--# hook is more suited to it.
--#
--# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
--# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
--
--# This example catches duplicate Signed-off-by lines.
--
--test "" = "$(grep '^Signed-off-by: ' "$1" |
--	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
--	echo >&2 Duplicate Signed-off-by lines.
--	exit 1
--}
-diff -ruN slock.org/.git/hooks/fsmonitor-watchman.sample slock/.git/hooks/fsmonitor-watchman.sample
---- slock.org/.git/hooks/fsmonitor-watchman.sample	2023-05-17 13:30:03.856466000 +0200
-+++ slock/.git/hooks/fsmonitor-watchman.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,174 +0,0 @@
--#!/usr/local/bin/perl
--
--use strict;
--use warnings;
--use IPC::Open2;
--
--# An example hook script to integrate Watchman
--# (https://facebook.github.io/watchman/) with git to speed up detecting
--# new and modified files.
--#
--# The hook is passed a version (currently 2) and last update token
--# formatted as a string and outputs to stdout a new update token and
--# all files that have been modified since the update token. Paths must
--# be relative to the root of the working tree and separated by a single NUL.
--#
--# To enable this hook, rename this file to "query-watchman" and set
--# 'git config core.fsmonitor .git/hooks/query-watchman'
--#
--my ($version, $last_update_token) = @ARGV;
--
--# Uncomment for debugging
--# print STDERR "$0 $version $last_update_token\n";
--
--# Check the hook interface version
--if ($version ne 2) {
--	die "Unsupported query-fsmonitor hook version '$version'.\n" .
--	    "Falling back to scanning...\n";
--}
--
--my $git_work_tree = get_working_dir();
--
--my $retry = 1;
--
--my $json_pkg;
--eval {
--	require JSON::XS;
--	$json_pkg = "JSON::XS";
--	1;
--} or do {
--	require JSON::PP;
--	$json_pkg = "JSON::PP";
--};
--
--launch_watchman();
--
--sub launch_watchman {
--	my $o = watchman_query();
--	if (is_work_tree_watched($o)) {
--		output_result($o->{clock}, @{$o->{files}});
--	}
--}
--
--sub output_result {
--	my ($clockid, @files) = @_;
--
--	# Uncomment for debugging watchman output
--	# open (my $fh, ">", ".git/watchman-output.out");
--	# binmode $fh, ":utf8";
--	# print $fh "$clockid\n@files\n";
--	# close $fh;
--
--	binmode STDOUT, ":utf8";
--	print $clockid;
--	print "\0";
--	local $, = "\0";
--	print @files;
--}
--
--sub watchman_clock {
--	my $response = qx/watchman clock "$git_work_tree"/;
--	die "Failed to get clock id on '$git_work_tree'.\n" .
--		"Falling back to scanning...\n" if $? != 0;
--
--	return $json_pkg->new->utf8->decode($response);
--}
--
--sub watchman_query {
--	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
--	or die "open2() failed: $!\n" .
--	"Falling back to scanning...\n";
--
--	# In the query expression below we're asking for names of files that
--	# changed since $last_update_token but not from the .git folder.
--	#
--	# To accomplish this, we're using the "since" generator to use the
--	# recency index to select candidate nodes and "fields" to limit the
--	# output to file names only. Then we're using the "expression" term to
--	# further constrain the results.
--	my $last_update_line = "";
--	if (substr($last_update_token, 0, 1) eq "c") {
--		$last_update_token = "\"$last_update_token\"";
--		$last_update_line = qq[\n"since": $last_update_token,];
--	}
--	my $query = <<"	END";
--		["query", "$git_work_tree", {$last_update_line
--			"fields": ["name"],
--			"expression": ["not", ["dirname", ".git"]]
--		}]
--	END
--
--	# Uncomment for debugging the watchman query
--	# open (my $fh, ">", ".git/watchman-query.json");
--	# print $fh $query;
--	# close $fh;
--
--	print CHLD_IN $query;
--	close CHLD_IN;
--	my $response = do {local $/; <CHLD_OUT>};
--
--	# Uncomment for debugging the watch response
--	# open ($fh, ">", ".git/watchman-response.json");
--	# print $fh $response;
--	# close $fh;
--
--	die "Watchman: command returned no output.\n" .
--	"Falling back to scanning...\n" if $response eq "";
--	die "Watchman: command returned invalid output: $response\n" .
--	"Falling back to scanning...\n" unless $response =~ /^\{/;
--
--	return $json_pkg->new->utf8->decode($response);
--}
--
--sub is_work_tree_watched {
--	my ($output) = @_;
--	my $error = $output->{error};
--	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
--		$retry--;
--		my $response = qx/watchman watch "$git_work_tree"/;
--		die "Failed to make watchman watch '$git_work_tree'.\n" .
--		    "Falling back to scanning...\n" if $? != 0;
--		$output = $json_pkg->new->utf8->decode($response);
--		$error = $output->{error};
--		die "Watchman: $error.\n" .
--		"Falling back to scanning...\n" if $error;
--
--		# Uncomment for debugging watchman output
--		# open (my $fh, ">", ".git/watchman-output.out");
--		# close $fh;
--
--		# Watchman will always return all files on the first query so
--		# return the fast "everything is dirty" flag to git and do the
--		# Watchman query just to get it over with now so we won't pay
--		# the cost in git to look up each individual file.
--		my $o = watchman_clock();
--		$error = $output->{error};
--
--		die "Watchman: $error.\n" .
--		"Falling back to scanning...\n" if $error;
--
--		output_result($o->{clock}, ("/"));
--		$last_update_token = $o->{clock};
--
--		eval { launch_watchman() };
--		return 0;
--	}
--
--	die "Watchman: $error.\n" .
--	"Falling back to scanning...\n" if $error;
--
--	return 1;
--}
--
--sub get_working_dir {
--	my $working_dir;
--	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
--		$working_dir = Win32::GetCwd();
--		$working_dir =~ tr/\\/\//;
--	} else {
--		require Cwd;
--		$working_dir = Cwd::cwd();
--	}
--
--	return $working_dir;
--}
-diff -ruN slock.org/.git/hooks/post-update.sample slock/.git/hooks/post-update.sample
---- slock.org/.git/hooks/post-update.sample	2023-05-17 13:30:03.856607000 +0200
-+++ slock/.git/hooks/post-update.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,8 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to prepare a packed repository for use over
--# dumb transports.
--#
--# To enable this hook, rename this file to "post-update".
--
--exec git update-server-info
-diff -ruN slock.org/.git/hooks/pre-applypatch.sample slock/.git/hooks/pre-applypatch.sample
---- slock.org/.git/hooks/pre-applypatch.sample	2023-05-17 13:30:03.857262000 +0200
-+++ slock/.git/hooks/pre-applypatch.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,14 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to verify what is about to be committed
--# by applypatch from an e-mail message.
--#
--# The hook should exit with non-zero status after issuing an
--# appropriate message if it wants to stop the commit.
--#
--# To enable this hook, rename this file to "pre-applypatch".
--
--. git-sh-setup
--precommit="$(git rev-parse --git-path hooks/pre-commit)"
--test -x "$precommit" && exec "$precommit" ${1+"$@"}
--:
-diff -ruN slock.org/.git/hooks/pre-commit.sample slock/.git/hooks/pre-commit.sample
---- slock.org/.git/hooks/pre-commit.sample	2023-05-17 13:30:03.856045000 +0200
-+++ slock/.git/hooks/pre-commit.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,49 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to verify what is about to be committed.
--# Called by "git commit" with no arguments.  The hook should
--# exit with non-zero status after issuing an appropriate message if
--# it wants to stop the commit.
--#
--# To enable this hook, rename this file to "pre-commit".
--
--if git rev-parse --verify HEAD >/dev/null 2>&1
--then
--	against=HEAD
--else
--	# Initial commit: diff against an empty tree object
--	against=$(git hash-object -t tree /dev/null)
--fi
--
--# If you want to allow non-ASCII filenames set this variable to true.
--allownonascii=$(git config --type=bool hooks.allownonascii)
--
--# Redirect output to stderr.
--exec 1>&2
--
--# Cross platform projects tend to avoid non-ASCII filenames; prevent
--# them from being added to the repository. We exploit the fact that the
--# printable range starts at the space character and ends with tilde.
--if [ "$allownonascii" != "true" ] &&
--	# Note that the use of brackets around a tr range is ok here, (it's
--	# even required, for portability to Solaris 10's /usr/bin/tr), since
--	# the square bracket bytes happen to fall in the designated range.
--	test $(git diff --cached --name-only --diff-filter=A -z $against |
--	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
--then
--	cat <<\EOF
--Error: Attempt to add a non-ASCII file name.
--
--This can cause problems if you want to work with people on other platforms.
--
--To be portable it is advisable to rename the file.
--
--If you know what you are doing you can disable this check using:
--
--  git config hooks.allownonascii true
--EOF
--	exit 1
--fi
--
--# If there are whitespace errors, print the offending file names and fail.
--exec git diff-index --check --cached $against --
-diff -ruN slock.org/.git/hooks/pre-merge-commit.sample slock/.git/hooks/pre-merge-commit.sample
---- slock.org/.git/hooks/pre-merge-commit.sample	2023-05-17 13:30:03.856187000 +0200
-+++ slock/.git/hooks/pre-merge-commit.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,13 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to verify what is about to be committed.
--# Called by "git merge" with no arguments.  The hook should
--# exit with non-zero status after issuing an appropriate message to
--# stderr if it wants to stop the merge commit.
--#
--# To enable this hook, rename this file to "pre-merge-commit".
--
--. git-sh-setup
--test -x "$GIT_DIR/hooks/pre-commit" &&
--        exec "$GIT_DIR/hooks/pre-commit"
--:
-diff -ruN slock.org/.git/hooks/pre-push.sample slock/.git/hooks/pre-push.sample
---- slock.org/.git/hooks/pre-push.sample	2023-05-17 13:30:03.857382000 +0200
-+++ slock/.git/hooks/pre-push.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,53 +0,0 @@
--#!/bin/sh
--
--# An example hook script to verify what is about to be pushed.  Called by "git
--# push" after it has checked the remote status, but before anything has been
--# pushed.  If this script exits with a non-zero status nothing will be pushed.
--#
--# This hook is called with the following parameters:
--#
--# $1 -- Name of the remote to which the push is being done
--# $2 -- URL to which the push is being done
--#
--# If pushing without using a named remote those arguments will be equal.
--#
--# Information about the commits which are being pushed is supplied as lines to
--# the standard input in the form:
--#
--#   <local ref> <local oid> <remote ref> <remote oid>
--#
--# This sample shows how to prevent push of commits where the log message starts
--# with "WIP" (work in progress).
--
--remote="$1"
--url="$2"
--
--zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
--
--while read local_ref local_oid remote_ref remote_oid
--do
--	if test "$local_oid" = "$zero"
--	then
--		# Handle delete
--		:
--	else
--		if test "$remote_oid" = "$zero"
--		then
--			# New branch, examine all commits
--			range="$local_oid"
--		else
--			# Update to existing branch, examine new commits
--			range="$remote_oid..$local_oid"
--		fi
--
--		# Check for WIP commit
--		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
--		if test -n "$commit"
--		then
--			echo >&2 "Found WIP commit in $local_ref, not pushing"
--			exit 1
--		fi
--	fi
--done
--
--exit 0
-diff -ruN slock.org/.git/hooks/pre-rebase.sample slock/.git/hooks/pre-rebase.sample
---- slock.org/.git/hooks/pre-rebase.sample	2023-05-17 13:30:03.857517000 +0200
-+++ slock/.git/hooks/pre-rebase.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,169 +0,0 @@
--#!/bin/sh
--#
--# Copyright (c) 2006, 2008 Junio C Hamano
--#
--# The "pre-rebase" hook is run just before "git rebase" starts doing
--# its job, and can prevent the command from running by exiting with
--# non-zero status.
--#
--# The hook is called with the following parameters:
--#
--# $1 -- the upstream the series was forked from.
--# $2 -- the branch being rebased (or empty when rebasing the current branch).
--#
--# This sample shows how to prevent topic branches that are already
--# merged to 'next' branch from getting rebased, because allowing it
--# would result in rebasing already published history.
--
--publish=next
--basebranch="$1"
--if test "$#" = 2
--then
--	topic="refs/heads/$2"
--else
--	topic=`git symbolic-ref HEAD` ||
--	exit 0 ;# we do not interrupt rebasing detached HEAD
--fi
--
--case "$topic" in
--refs/heads/??/*)
--	;;
--*)
--	exit 0 ;# we do not interrupt others.
--	;;
--esac
--
--# Now we are dealing with a topic branch being rebased
--# on top of master.  Is it OK to rebase it?
--
--# Does the topic really exist?
--git show-ref -q "$topic" || {
--	echo >&2 "No such branch $topic"
--	exit 1
--}
--
--# Is topic fully merged to master?
--not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
--if test -z "$not_in_master"
--then
--	echo >&2 "$topic is fully merged to master; better remove it."
--	exit 1 ;# we could allow it, but there is no point.
--fi
--
--# Is topic ever merged to next?  If so you should not be rebasing it.
--only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
--only_next_2=`git rev-list ^master           ${publish} | sort`
--if test "$only_next_1" = "$only_next_2"
--then
--	not_in_topic=`git rev-list "^$topic" master`
--	if test -z "$not_in_topic"
--	then
--		echo >&2 "$topic is already up to date with master"
--		exit 1 ;# we could allow it, but there is no point.
--	else
--		exit 0
--	fi
--else
--	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
--	/usr/local/bin/perl -e '
--		my $topic = $ARGV[0];
--		my $msg = "* $topic has commits already merged to public branch:\n";
--		my (%not_in_next) = map {
--			/^([0-9a-f]+) /;
--			($1 => 1);
--		} split(/\n/, $ARGV[1]);
--		for my $elem (map {
--				/^([0-9a-f]+) (.*)$/;
--				[$1 => $2];
--			} split(/\n/, $ARGV[2])) {
--			if (!exists $not_in_next{$elem->[0]}) {
--				if ($msg) {
--					print STDERR $msg;
--					undef $msg;
--				}
--				print STDERR " $elem->[1]\n";
--			}
--		}
--	' "$topic" "$not_in_next" "$not_in_master"
--	exit 1
--fi
--
--<<\DOC_END
--
--This sample hook safeguards topic branches that have been
--published from being rewound.
--
--The workflow assumed here is:
--
-- * Once a topic branch forks from "master", "master" is never
--   merged into it again (either directly or indirectly).
--
-- * Once a topic branch is fully cooked and merged into "master",
--   it is deleted.  If you need to build on top of it to correct
--   earlier mistakes, a new topic branch is created by forking at
--   the tip of the "master".  This is not strictly necessary, but
--   it makes it easier to keep your history simple.
--
-- * Whenever you need to test or publish your changes to topic
--   branches, merge them into "next" branch.
--
--The script, being an example, hardcodes the publish branch name
--to be "next", but it is trivial to make it configurable via
--$GIT_DIR/config mechanism.
--
--With this workflow, you would want to know:
--
--(1) ... if a topic branch has ever been merged to "next".  Young
--    topic branches can have stupid mistakes you would rather
--    clean up before publishing, and things that have not been
--    merged into other branches can be easily rebased without
--    affecting other people.  But once it is published, you would
--    not want to rewind it.
--
--(2) ... if a topic branch has been fully merged to "master".
--    Then you can delete it.  More importantly, you should not
--    build on top of it -- other people may already want to
--    change things related to the topic as patches against your
--    "master", so if you need further changes, it is better to
--    fork the topic (perhaps with the same name) afresh from the
--    tip of "master".
--
--Let's look at this example:
--
--		   o---o---o---o---o---o---o---o---o---o "next"
--		  /       /           /           /
--		 /   a---a---b A     /           /
--		/   /               /           /
--	       /   /   c---c---c---c B         /
--	      /   /   /             \         /
--	     /   /   /   b---b C     \       /
--	    /   /   /   /             \     /
--    ---o---o---o---o---o---o---o---o---o---o---o "master"
--
--
--A, B and C are topic branches.
--
-- * A has one fix since it was merged up to "next".
--
-- * B has finished.  It has been fully merged up to "master" and "next",
--   and is ready to be deleted.
--
-- * C has not merged to "next" at all.
--
--We would want to allow C to be rebased, refuse A, and encourage
--B to be deleted.
--
--To compute (1):
--
--	git rev-list ^master ^topic next
--	git rev-list ^master        next
--
--	if these match, topic has not merged in next at all.
--
--To compute (2):
--
--	git rev-list master..topic
--
--	if this is empty, it is fully merged to "master".
--
--DOC_END
-diff -ruN slock.org/.git/hooks/pre-receive.sample slock/.git/hooks/pre-receive.sample
---- slock.org/.git/hooks/pre-receive.sample	2023-05-17 13:30:03.856314000 +0200
-+++ slock/.git/hooks/pre-receive.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,24 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to make use of push options.
--# The example simply echoes all push options that start with 'echoback='
--# and rejects all pushes when the "reject" push option is used.
--#
--# To enable this hook, rename this file to "pre-receive".
--
--if test -n "$GIT_PUSH_OPTION_COUNT"
--then
--	i=0
--	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
--	do
--		eval "value=\$GIT_PUSH_OPTION_$i"
--		case "$value" in
--		echoback=*)
--			echo "echo from the pre-receive-hook: ${value#*=}" >&2
--			;;
--		reject)
--			exit 1
--		esac
--		i=$((i + 1))
--	done
--fi
-diff -ruN slock.org/.git/hooks/prepare-commit-msg.sample slock/.git/hooks/prepare-commit-msg.sample
---- slock.org/.git/hooks/prepare-commit-msg.sample	2023-05-17 13:30:03.857140000 +0200
-+++ slock/.git/hooks/prepare-commit-msg.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,42 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to prepare the commit log message.
--# Called by "git commit" with the name of the file that has the
--# commit message, followed by the description of the commit
--# message's source.  The hook's purpose is to edit the commit
--# message file.  If the hook fails with a non-zero status,
--# the commit is aborted.
--#
--# To enable this hook, rename this file to "prepare-commit-msg".
--
--# This hook includes three examples. The first one removes the
--# "# Please enter the commit message..." help message.
--#
--# The second includes the output of "git diff --name-status -r"
--# into the message, just before the "git status" output.  It is
--# commented because it doesn't cope with --amend or with squashed
--# commits.
--#
--# The third example adds a Signed-off-by line to the message, that can
--# still be edited.  This is rarely a good idea.
--
--COMMIT_MSG_FILE=$1
--COMMIT_SOURCE=$2
--SHA1=$3
--
--/usr/local/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
--
--# case "$COMMIT_SOURCE,$SHA1" in
--#  ,|template,)
--#    /usr/local/bin/perl -i.bak -pe '
--#       print "\n" . `git diff --cached --name-status -r`
--# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
--#  *) ;;
--# esac
--
--# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
--# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
--# if test -z "$COMMIT_SOURCE"
--# then
--#   /usr/local/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
--# fi
-diff -ruN slock.org/.git/hooks/push-to-checkout.sample slock/.git/hooks/push-to-checkout.sample
---- slock.org/.git/hooks/push-to-checkout.sample	2023-05-17 13:30:03.855903000 +0200
-+++ slock/.git/hooks/push-to-checkout.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,78 +0,0 @@
--#!/bin/sh
--
--# An example hook script to update a checked-out tree on a git push.
--#
--# This hook is invoked by git-receive-pack(1) when it reacts to git
--# push and updates reference(s) in its repository, and when the push
--# tries to update the branch that is currently checked out and the
--# receive.denyCurrentBranch configuration variable is set to
--# updateInstead.
--#
--# By default, such a push is refused if the working tree and the index
--# of the remote repository has any difference from the currently
--# checked out commit; when both the working tree and the index match
--# the current commit, they are updated to match the newly pushed tip
--# of the branch. This hook is to be used to override the default
--# behaviour; however the code below reimplements the default behaviour
--# as a starting point for convenient modification.
--#
--# The hook receives the commit with which the tip of the current
--# branch is going to be updated:
--commit=$1
--
--# It can exit with a non-zero status to refuse the push (when it does
--# so, it must not modify the index or the working tree).
--die () {
--	echo >&2 "$*"
--	exit 1
--}
--
--# Or it can make any necessary changes to the working tree and to the
--# index to bring them to the desired state when the tip of the current
--# branch is updated to the new commit, and exit with a zero status.
--#
--# For example, the hook can simply run git read-tree -u -m HEAD "$1"
--# in order to emulate git fetch that is run in the reverse direction
--# with git push, as the two-tree form of git read-tree -u -m is
--# essentially the same as git switch or git checkout that switches
--# branches while keeping the local changes in the working tree that do
--# not interfere with the difference between the branches.
--
--# The below is a more-or-less exact translation to shell of the C code
--# for the default behaviour for git's push-to-checkout hook defined in
--# the push_to_deploy() function in builtin/receive-pack.c.
--#
--# Note that the hook will be executed from the repository directory,
--# not from the working tree, so if you want to perform operations on
--# the working tree, you will have to adapt your code accordingly, e.g.
--# by adding "cd .." or using relative paths.
--
--if ! git update-index -q --ignore-submodules --refresh
--then
--	die "Up-to-date check failed"
--fi
--
--if ! git diff-files --quiet --ignore-submodules --
--then
--	die "Working directory has unstaged changes"
--fi
--
--# This is a rough translation of:
--#
--#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
--if git cat-file -e HEAD 2>/dev/null
--then
--	head=HEAD
--else
--	head=$(git hash-object -t tree --stdin </dev/null)
--fi
--
--if ! git diff-index --quiet --cached --ignore-submodules $head --
--then
--	die "Working directory has staged changes"
--fi
--
--if ! git read-tree -u -m "$commit"
--then
--	die "Could not update working tree to new HEAD"
--fi
-diff -ruN slock.org/.git/hooks/update.sample slock/.git/hooks/update.sample
---- slock.org/.git/hooks/update.sample	2023-05-17 13:30:03.856746000 +0200
-+++ slock/.git/hooks/update.sample	1970-01-01 01:00:00.000000000 +0100
-@@ -1,128 +0,0 @@
--#!/bin/sh
--#
--# An example hook script to block unannotated tags from entering.
--# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
--#
--# To enable this hook, rename this file to "update".
--#
--# Config
--# ------
--# hooks.allowunannotated
--#   This boolean sets whether unannotated tags will be allowed into the
--#   repository.  By default they won't be.
--# hooks.allowdeletetag
--#   This boolean sets whether deleting tags will be allowed in the
--#   repository.  By default they won't be.
--# hooks.allowmodifytag
--#   This boolean sets whether a tag may be modified after creation. By default
--#   it won't be.
--# hooks.allowdeletebranch
--#   This boolean sets whether deleting branches will be allowed in the
--#   repository.  By default they won't be.
--# hooks.denycreatebranch
--#   This boolean sets whether remotely creating branches will be denied
--#   in the repository.  By default this is allowed.
--#
--
--# --- Command line
--refname="$1"
--oldrev="$2"
--newrev="$3"
--
--# --- Safety check
--if [ -z "$GIT_DIR" ]; then
--	echo "Don't run this script from the command line." >&2
--	echo " (if you want, you could supply GIT_DIR then run" >&2
--	echo "  $0 <ref> <oldrev> <newrev>)" >&2
--	exit 1
--fi
--
--if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
--	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
--	exit 1
--fi
--
--# --- Config
--allowunannotated=$(git config --type=bool hooks.allowunannotated)
--allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
--denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
--allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
--allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
--
--# check for no description
--projectdesc=$(sed -e '1q' "$GIT_DIR/description")
--case "$projectdesc" in
--"Unnamed repository"* | "")
--	echo "*** Project description file hasn't been set" >&2
--	exit 1
--	;;
--esac
--
--# --- Check types
--# if $newrev is 0000...0000, it's a commit to delete a ref.
--zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
--if [ "$newrev" = "$zero" ]; then
--	newrev_type=delete
--else
--	newrev_type=$(git cat-file -t $newrev)
--fi
--
--case "$refname","$newrev_type" in
--	refs/tags/*,commit)
--		# un-annotated tag
--		short_refname=${refname##refs/tags/}
--		if [ "$allowunannotated" != "true" ]; then
--			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
--			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
--			exit 1
--		fi
--		;;
--	refs/tags/*,delete)
--		# delete tag
--		if [ "$allowdeletetag" != "true" ]; then
--			echo "*** Deleting a tag is not allowed in this repository" >&2
--			exit 1
--		fi
--		;;
--	refs/tags/*,tag)
--		# annotated tag
--		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
--		then
--			echo "*** Tag '$refname' already exists." >&2
--			echo "*** Modifying a tag is not allowed in this repository." >&2
--			exit 1
--		fi
--		;;
--	refs/heads/*,commit)
--		# branch
--		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
--			echo "*** Creating a branch is not allowed in this repository" >&2
--			exit 1
--		fi
--		;;
--	refs/heads/*,delete)
--		# delete branch
--		if [ "$allowdeletebranch" != "true" ]; then
--			echo "*** Deleting a branch is not allowed in this repository" >&2
--			exit 1
--		fi
--		;;
--	refs/remotes/*,commit)
--		# tracking branch
--		;;
--	refs/remotes/*,delete)
--		# delete tracking branch
--		if [ "$allowdeletebranch" != "true" ]; then
--			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
--			exit 1
--		fi
--		;;
--	*)
--		# Anything else (is there anything else?)
--		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
--		exit 1
--		;;
--esac
--
--# --- Finished
--exit 0
-Binary files slock.org/.git/index and slock/.git/index differ
-diff -ruN slock.org/.git/info/exclude slock/.git/info/exclude
---- slock.org/.git/info/exclude	2023-05-17 13:30:03.857686000 +0200
-+++ slock/.git/info/exclude	1970-01-01 01:00:00.000000000 +0100
-@@ -1,6 +0,0 @@
--# git ls-files --others --exclude-from=.git/info/exclude
--# Lines that start with '#' are comments.
--# For a project mostly in C, the following would be a good set of
--# exclude patterns (uncomment them if you want to use them):
--# *.[oa]
--# *~
-diff -ruN slock.org/.git/logs/HEAD slock/.git/logs/HEAD
---- slock.org/.git/logs/HEAD	2023-05-17 13:30:04.569541000 +0200
-+++ slock/.git/logs/HEAD	1970-01-01 01:00:00.000000000 +0100
-@@ -1 +0,0 @@
--0000000000000000000000000000000000000000 4f045545a25cc02c64bfc08d27ed2ccecb962292 Charlie Root <root@apostroph.(none)> 1684323004 +0200	clone: from https://git.suckless.org/slock
-diff -ruN slock.org/.git/logs/refs/heads/master slock/.git/logs/refs/heads/master
---- slock.org/.git/logs/refs/heads/master	2023-05-17 13:30:04.569723000 +0200
-+++ slock/.git/logs/refs/heads/master	1970-01-01 01:00:00.000000000 +0100
-@@ -1 +0,0 @@
--0000000000000000000000000000000000000000 4f045545a25cc02c64bfc08d27ed2ccecb962292 Charlie Root <root@apostroph.(none)> 1684323004 +0200	clone: from https://git.suckless.org/slock
-diff -ruN slock.org/.git/logs/refs/remotes/origin/HEAD slock/.git/logs/refs/remotes/origin/HEAD
---- slock.org/.git/logs/refs/remotes/origin/HEAD	2023-05-17 13:30:04.568516000 +0200
-+++ slock/.git/logs/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
-@@ -1 +0,0 @@
--0000000000000000000000000000000000000000 4f045545a25cc02c64bfc08d27ed2ccecb962292 Charlie Root <root@apostroph.(none)> 1684323004 +0200	clone: from https://git.suckless.org/slock
-Binary files slock.org/.git/objects/pack/pack-e8228a18d24fc3df9e35b901bc6dd1f953e6cd57.idx and slock/.git/objects/pack/pack-e8228a18d24fc3df9e35b901bc6dd1f953e6cd57.idx differ
-Binary files slock.org/.git/objects/pack/pack-e8228a18d24fc3df9e35b901bc6dd1f953e6cd57.pack and slock/.git/objects/pack/pack-e8228a18d24fc3df9e35b901bc6dd1f953e6cd57.pack differ
-diff -ruN slock.org/.git/packed-refs slock/.git/packed-refs
---- slock.org/.git/packed-refs	2023-05-17 13:30:04.485620000 +0200
-+++ slock/.git/packed-refs	1970-01-01 01:00:00.000000000 +0100
-@@ -1,18 +0,0 @@
--# pack-refs with: peeled fully-peeled sorted 
--4f045545a25cc02c64bfc08d27ed2ccecb962292 refs/remotes/origin/master
--dead0bb22e45a85a79f19d1378d263613e00db9e refs/tags/0.1
--10ccc43597910428a22129cd942881835d95b5c0 refs/tags/0.2
--ff79c382c5d1c83c8e771223cbb99bc0e87be697 refs/tags/0.3
--6725bb2a3a425ffff9c2253d60c0f25513c78a93 refs/tags/0.4
--8322f22871ee1da82546dfcdea484ef9db6d4942 refs/tags/0.5
--48a7ab2225d1e53a8e0fd73bca975bb7695d1b06 refs/tags/0.6
--6fdf8be2044145c11f7e1eb165613f791c514520 refs/tags/0.7
--98e2fef63d2e6dbda63929867db70bee1f8b55f5 refs/tags/0.8
--a6a3471dd9c693837b3038be0a2ccc839c94570b refs/tags/0.9
--34f5edb29e3947d105235c1fc07be57eda5adeb5 refs/tags/1.0
--66e31556db4921b5f24ced47dae5e1c7ea3bd150 refs/tags/1.2
--1c858ec620c37e5c6882702c34eac7c1f450a1e2 refs/tags/1.3
--^6a52a85a1ac87b29048863d599a8b0f0ee712482
--26b12a4d39081064a043c74fda9bd8395763ac3f refs/tags/1.4
--^fa1158958466f38cd35c9114023a0175e67ebb6f
--4f045545a25cc02c64bfc08d27ed2ccecb962292 refs/tags/1.5
-diff -ruN slock.org/.git/refs/heads/master slock/.git/refs/heads/master
---- slock.org/.git/refs/heads/master	2023-05-17 13:30:04.569437000 +0200
-+++ slock/.git/refs/heads/master	1970-01-01 01:00:00.000000000 +0100
-@@ -1 +0,0 @@
--4f045545a25cc02c64bfc08d27ed2ccecb962292
-diff -ruN slock.org/.git/refs/remotes/origin/HEAD slock/.git/refs/remotes/origin/HEAD
---- slock.org/.git/refs/remotes/origin/HEAD	2023-05-17 13:30:04.568579000 +0200
-+++ slock/.git/refs/remotes/origin/HEAD	1970-01-01 01:00:00.000000000 +0100
-@@ -1 +0,0 @@
--ref: refs/remotes/origin/master
-diff -ruN slock.org/config.def.h slock/config.def.h
---- slock.org/config.def.h	2023-05-17 13:30:04.572389000 +0200
-+++ slock/config.def.h	2023-05-17 13:27:05.256468000 +0200
-@@ -1,12 +1,38 @@
--/* user and group to drop privileges to */
--static const char *user  = "nobody";
--static const char *group = "nogroup";
--
- static const char *colorname[NUMCOLS] = {
--	[INIT] =   "black",     /* after initialization */
-+    [BACKGROUND] = "white",
-+	[INIT] =   "2d2d2d",     /* after initialization */
- 	[INPUT] =  "#005577",   /* during input */
- 	[FAILED] = "#CC3333",   /* wrong password */
-+	[CAPS] = "yellow",         /* CapsLock on */
- };
- 
- /* treat a cleared input like a wrong password (color) */
- static const int failonclear = 1;
-+
-+/* time in seconds before the monitor shuts down */
-+static const int monitortime = 10;
-+
-+static const int logosize = 75;
-+static const int logow = 12; /* Grid width and height for right center alignment*/
-+static const int logoh = 6;
-+
-+static XRectangle rectangles[9] = {
-+    {0, 3, 1, 3},
-+    {1, 3, 2, 1},
-+    {0, 5, 8, 1},
-+    {3, 0, 1, 5},
-+    {5, 3, 1, 2},
-+    {7, 3, 1, 2},
-+    {8, 3, 4, 1},
-+    {9, 4, 1, 2},
-+    {11,4, 1, 2},
-+};
-+
-+/*Enable blur*/
-+#define BLUR
-+/*Set blur radius*/
-+static const int blurRadius=5;
-+/*Enable Pixelation*/
-+//#define PIXELATION
-+/*Set pixelation radius*/
-+static const int pixelSize=0;
-diff -ruN slock.org/config.h slock/config.h
---- slock.org/config.h	1970-01-01 01:00:00.000000000 +0100
-+++ slock/config.h	2023-05-17 13:28:38.768901000 +0200
-@@ -0,0 +1,38 @@
-+static const char *colorname[NUMCOLS] = {
-+    [BACKGROUND] = "white",
-+	[INIT] =   "2d2d2d",     /* after initialization */
-+	[INPUT] =  "#005577",   /* during input */
-+	[FAILED] = "#CC3333",   /* wrong password */
-+	[CAPS] = "yellow",         /* CapsLock on */
-+};
-+
-+/* treat a cleared input like a wrong password (color) */
-+static const int failonclear = 1;
-+
-+/* time in seconds before the monitor shuts down */
-+static const int monitortime = 10;
-+
-+static const int logosize = 75;
-+static const int logow = 12; /* Grid width and height for right center alignment*/
-+static const int logoh = 6;
-+
-+static XRectangle rectangles[9] = {
-+    {0, 3, 1, 3},
-+    {1, 3, 2, 1},
-+    {0, 5, 8, 1},
-+    {3, 0, 1, 5},
-+    {5, 3, 1, 2},
-+    {7, 3, 1, 2},
-+    {8, 3, 4, 1},
-+    {9, 4, 1, 2},
-+    {11,4, 1, 2},
-+};
-+
-+/*Enable blur*/
-+#define BLUR
-+/*Set blur radius*/
-+static const int blurRadius=5;
-+/*Enable Pixelation*/
-+//#define PIXELATION
-+/*Set pixelation radius*/
-+static const int pixelSize=0;
-diff -ruN slock.org/config.mk slock/config.mk
---- slock.org/config.mk	2023-05-17 13:30:04.572562000 +0200
-+++ slock/config.mk	2023-05-13 11:20:37.221903000 +0200
-@@ -7,16 +7,24 @@
- PREFIX = /usr/local
- MANPREFIX = ${PREFIX}/share/man
- 
--X11INC = /usr/X11R6/include
--X11LIB = /usr/X11R6/lib
-+X11INC = /usr/local/include
-+X11LIB = /usr/local/lib
- 
-+# Xinerama, comment if you don't want it
-+XINERAMALIBS = -lXinerama
-+XINERAMAFLAGS = -DXINERAMA
-+
-+# freetype
-+FREETYPELIBS = -lXft
-+FREETYPEINC = /usr/include/freetype2
-+
- # includes and libs
--INCS = -I. -I/usr/include -I${X11INC}
--LIBS = -L/usr/lib -lc -lcrypt -L${X11LIB} -lX11 -lXext -lXrandr
-+INCS = -I. -I/usr/include -I${X11INC} -I${FREETYPEINC}
-+LIBS = -L/usr/lib -lc -lcrypt -L${X11LIB} -lX11 -lImlib2 ${XINERAMALIBS} ${FREETYPELIBS} -lXext -lXrandr
- 
- # flags
--CPPFLAGS = -DVERSION=\"${VERSION}\" -D_DEFAULT_SOURCE -DHAVE_SHADOW_H
--CFLAGS = -std=c99 -pedantic -Wall -Os ${INCS} ${CPPFLAGS}
-+CPPFLAGS = -DVERSION=\"${VERSION}\" -D_DEFAULT_SOURCE -DHAVE_PAM ${XINERAMAFLAGS}
-+CFLAGS = -std=c99 -pedantic -Wall -Ofast ${INCS} ${CPPFLAGS}
- LDFLAGS = -s ${LIBS}
- COMPATSRC = explicit_bzero.c
- 
-diff -ruN slock.org/slock.c slock/slock.c
---- slock.org/slock.c	2023-05-17 13:30:04.573333000 +0200
-+++ slock/slock.c	2023-05-17 13:24:09.331656000 +0200
-@@ -1,5 +1,6 @@
- /* See LICENSE file for license details. */
--#define _XOPEN_SOURCE 500
-+#define _XOPEN_SOURCE   500
-+#define LENGTH(X)       (sizeof X / sizeof X[0])
- #if HAVE_SHADOW_H
- #include <shadow.h>
- #endif
-@@ -15,9 +16,14 @@
- #include <unistd.h>
- #include <sys/types.h>
- #include <X11/extensions/Xrandr.h>
-+#ifdef XINERAMA
-+#include <X11/extensions/Xinerama.h>
-+#endif
- #include <X11/keysym.h>
- #include <X11/Xlib.h>
- #include <X11/Xutil.h>
-+#include <X11/XKBlib.h>
-+#include <Imlib2.h>
- 
- #include "arg.h"
- #include "util.h"
-@@ -25,17 +31,27 @@
- char *argv0;
- 
- enum {
-+    BACKGROUND,
- 	INIT,
- 	INPUT,
- 	FAILED,
-+	CAPS,
- 	NUMCOLS
- };
- 
-+#include "config.h"
-+
- struct lock {
- 	int screen;
- 	Window root, win;
- 	Pixmap pmap;
-+	Pixmap bgmap;
- 	unsigned long colors[NUMCOLS];
-+    unsigned int x, y;
-+    unsigned int xoff, yoff, mw, mh;
-+    Drawable drawable;
-+    GC gc;
-+    XRectangle rectangles[LENGTH(rectangles)];
- };
- 
- struct xrandr {
-@@ -44,7 +60,7 @@
- 	int errbase;
- };
- 
--#include "config.h"
-+Imlib_Image image;
- 
- static void
- die(const char *errstr, ...)
-@@ -125,21 +141,48 @@
- }
- 
- static void
-+resizerectangles(struct lock *lock)
-+{
-+	int i;
-+
-+	for (i = 0; i < LENGTH(rectangles); i++){
-+		lock->rectangles[i].x = (rectangles[i].x * logosize)
-+                                + lock->xoff + ((lock->mw) / 2) - (logow / 2 * logosize);
-+		lock->rectangles[i].y = (rectangles[i].y * logosize)
-+                                + lock->yoff + ((lock->mh) / 2) - (logoh / 2 * logosize);
-+		lock->rectangles[i].width = rectangles[i].width * logosize;
-+		lock->rectangles[i].height = rectangles[i].height * logosize;
-+	}
-+}
-+
-+static void
-+drawlogo(Display *dpy, struct lock *lock, int color)
-+{
-+	XSetForeground(dpy, lock->gc, lock->colors[color]);
-+	XFillRectangles(dpy, lock->win, lock->gc, lock->rectangles, LENGTH(rectangles));
-+	XSync(dpy, False);
-+}
-+
-+static void
- readpw(Display *dpy, struct xrandr *rr, struct lock **locks, int nscreens,
-        const char *hash)
- {
- 	XRRScreenChangeNotifyEvent *rre;
- 	char buf[32], passwd[256], *inputhash;
--	int num, screen, running, failure, oldc;
--	unsigned int len, color;
-+	int caps, num, screen, running, failure, oldc;
-+	unsigned int len, color, indicators;
- 	KeySym ksym;
- 	XEvent ev;
- 
- 	len = 0;
-+	caps = 0;
- 	running = 1;
- 	failure = 0;
- 	oldc = INIT;
- 
-+	if (!XkbGetIndicatorState(dpy, XkbUseCoreKbd, &indicators))
-+		caps = indicators & 1;
-+
- 	while (running && !XNextEvent(dpy, &ev)) {
- 		if (ev.type == KeyPress) {
- 			explicit_bzero(&buf, sizeof(buf));
-@@ -179,6 +222,9 @@
- 				if (len)
- 					passwd[--len] = '\0';
- 				break;
-+			case XK_Caps_Lock:
-+				caps = !caps;
-+				break;
- 			default:
- 				if (num && !iscntrl((int)buf[0]) &&
- 				    (len + num < sizeof(passwd))) {
-@@ -187,13 +233,15 @@
- 				}
- 				break;
- 			}
--			color = len ? INPUT : ((failure || failonclear) ? FAILED : INIT);
-+			color = len ? (caps ? CAPS : INPUT) : (failure || failonclear ? FAILED : INIT);
- 			if (running && oldc != color) {
- 				for (screen = 0; screen < nscreens; screen++) {
--					XSetWindowBackground(dpy,
--					                     locks[screen]->win,
--					                     locks[screen]->colors[color]);
--					XClearWindow(dpy, locks[screen]->win);
-+                    if(locks[screen]->bgmap)
-+                        XSetWindowBackgroundPixmap(dpy, locks[screen]->win, locks[screen]->bgmap);
-+                    else
-+                        XSetWindowBackground(dpy, locks[screen]->win, locks[screen]->colors[0]);
-+					//XClearWindow(dpy, locks[screen]->win);
-+                    drawlogo(dpy, locks[screen], color);
- 				}
- 				oldc = color;
- 			}
-@@ -228,6 +276,10 @@
- 	XColor color, dummy;
- 	XSetWindowAttributes wa;
- 	Cursor invisible;
-+#ifdef XINERAMA
-+	XineramaScreenInfo *info;
-+	int n;
-+#endif
- 
- 	if (dpy == NULL || screen < 0 || !(lock = malloc(sizeof(struct lock))))
- 		return NULL;
-@@ -235,27 +287,61 @@
- 	lock->screen = screen;
- 	lock->root = RootWindow(dpy, lock->screen);
- 
-+    if(image) 
-+    {
-+        lock->bgmap = XCreatePixmap(dpy, lock->root, DisplayWidth(dpy, lock->screen), DisplayHeight(dpy, lock->screen), DefaultDepth(dpy, lock->screen));
-+        imlib_context_set_image(image);
-+        imlib_context_set_display(dpy);
-+        imlib_context_set_visual(DefaultVisual(dpy, lock->screen));
-+        imlib_context_set_colormap(DefaultColormap(dpy, lock->screen));
-+        imlib_context_set_drawable(lock->bgmap);
-+        imlib_render_image_on_drawable(0, 0);
-+        imlib_free_image();
-+    }
- 	for (i = 0; i < NUMCOLS; i++) {
- 		XAllocNamedColor(dpy, DefaultColormap(dpy, lock->screen),
- 		                 colorname[i], &color, &dummy);
- 		lock->colors[i] = color.pixel;
- 	}
- 
-+	lock->x = DisplayWidth(dpy, lock->screen);
-+	lock->y = DisplayHeight(dpy, lock->screen);
-+#ifdef XINERAMA
-+	if ((info = XineramaQueryScreens(dpy, &n))) {
-+		lock->xoff = info[0].x_org;
-+		lock->yoff = info[0].y_org;
-+		lock->mw = info[0].width;
-+		lock->mh = info[0].height;
-+	} else
-+#endif
-+	{
-+		lock->xoff = lock->yoff = 0;
-+		lock->mw = lock->x;
-+		lock->mh = lock->y;
-+	}
-+	lock->drawable = XCreatePixmap(dpy, lock->root,
-+            lock->x, lock->y, DefaultDepth(dpy, screen));
-+	lock->gc = XCreateGC(dpy, lock->root, 0, NULL);
-+	XSetLineAttributes(dpy, lock->gc, 1, LineSolid, CapButt, JoinMiter);
-+
- 	/* init */
- 	wa.override_redirect = 1;
--	wa.background_pixel = lock->colors[INIT];
-+	wa.background_pixel = lock->colors[BACKGROUND];
- 	lock->win = XCreateWindow(dpy, lock->root, 0, 0,
--	                          DisplayWidth(dpy, lock->screen),
--	                          DisplayHeight(dpy, lock->screen),
-+	                          lock->x, lock->y,
- 	                          0, DefaultDepth(dpy, lock->screen),
- 	                          CopyFromParent,
- 	                          DefaultVisual(dpy, lock->screen),
- 	                          CWOverrideRedirect | CWBackPixel, &wa);
-+    	if(lock->bgmap)
-+        	XSetWindowBackgroundPixmap(dpy, lock->win, lock->bgmap);
- 	lock->pmap = XCreateBitmapFromData(dpy, lock->win, curs, 8, 8);
- 	invisible = XCreatePixmapCursor(dpy, lock->pmap, lock->pmap,
- 	                                &color, &color, 0, 0);
- 	XDefineCursor(dpy, lock->win, invisible);
- 
-+	resizerectangles(lock);
-+
- 	/* Try to grab mouse pointer *and* keyboard for 600ms, else fail the lock */
- 	for (i = 0, ptgrab = kbgrab = -1; i < 6; i++) {
- 		if (ptgrab != GrabSuccess) {
-@@ -276,6 +362,7 @@
- 				XRRSelectInput(dpy, lock->win, RRScreenChangeNotifyMask);
- 
- 			XSelectInput(dpy, lock->root, SubstructureNotifyMask);
-+			drawlogo(dpy, lock, INIT);
- 			return lock;
- 		}
- 
-@@ -325,13 +412,13 @@
- 
- 	/* validate drop-user and -group */
- 	errno = 0;
--	if (!(pwd = getpwnam(user)))
--		die("slock: getpwnam %s: %s\n", user,
-+	if (!(pwd = getpwnam(getenv("USER"))))
-+		die("slock: getpwnam %s: %s\n", getenv("USER"),
- 		    errno ? strerror(errno) : "user entry not found");
- 	duid = pwd->pw_uid;
- 	errno = 0;
--	if (!(grp = getgrnam(group)))
--		die("slock: getgrnam %s: %s\n", group,
-+	if (!(grp = getgrnam(getenv("USER"))))
-+		die("slock: getgrnam %s: %s\n", getenv("USER"),
- 		    errno ? strerror(errno) : "group entry not found");
- 	dgid = grp->gr_gid;
- 
-@@ -355,6 +442,60 @@
- 	if (setuid(duid) < 0)
- 		die("slock: setuid: %s\n", strerror(errno));
- 
-+	/*Create screenshot Image*/
-+	Screen *scr = ScreenOfDisplay(dpy, DefaultScreen(dpy));
-+	image = imlib_create_image(scr->width,scr->height);
-+	imlib_context_set_image(image);
-+	imlib_context_set_display(dpy);
-+	imlib_context_set_visual(DefaultVisual(dpy,0));
-+	imlib_context_set_drawable(RootWindow(dpy,XScreenNumberOfScreen(scr)));	
-+	imlib_copy_drawable_to_image(0,0,0,scr->width,scr->height,0,0,1);
-+
-+#ifdef BLUR
-+
-+	/*Blur function*/
-+	imlib_image_blur(blurRadius);
-+#endif // BLUR	
-+
-+#ifdef PIXELATION
-+	/*Pixelation*/
-+	int width = scr->width;
-+	int height = scr->height;
-+	
-+	for(int y = 0; y < height; y += pixelSize)
-+	{
-+		for(int x = 0; x < width; x += pixelSize)
-+		{
-+			int red = 0;
-+			int green = 0;
-+			int blue = 0;
-+
-+			Imlib_Color pixel; 
-+			Imlib_Color* pp;
-+			pp = &pixel;
-+			for(int j = 0; j < pixelSize && j < height; j++)
-+			{
-+				for(int i = 0; i < pixelSize && i < width; i++)
-+				{
-+					imlib_image_query_pixel(x+i,y+j,pp);
-+					red += pixel.red;
-+					green += pixel.green;
-+					blue += pixel.blue;
-+				}
-+			}
-+			red /= (pixelSize*pixelSize);
-+			green /= (pixelSize*pixelSize);
-+			blue /= (pixelSize*pixelSize);
-+			imlib_context_set_color(red,green,blue,pixel.alpha);
-+			imlib_image_fill_rectangle(x,y,pixelSize,pixelSize);
-+			red = 0;
-+			green = 0;
-+			blue = 0;
-+		}
-+	}
-+	
-+	
-+#endif
- 	/* check for Xrandr support */
- 	rr.active = XRRQueryExtension(dpy, &rr.evbase, &rr.errbase);
- 
-@@ -391,5 +532,12 @@
- 	/* everything is now blank. Wait for the correct password */
- 	readpw(dpy, &rr, locks, nscreens, hash);
- 
-+	for (nlocks = 0, s = 0; s < nscreens; s++) {
-+		XFreePixmap(dpy, locks[s]->drawable);
-+		XFreeGC(dpy, locks[s]->gc);
-+	}
-+
-+	XSync(dpy, 0);
-+	XCloseDisplay(dpy);
- 	return 0;
- }
diff -ruN slock.org/slock.c slock/slock.c
--- slock.org/slock.c	2023-05-17 13:30:04.573333000 +0200
+++ slock/slock.c	2023-05-17 13:24:09.331656000 +0200
@@ -1,5 +1,6 @@
 /* See LICENSE file for license details. */
-#define _XOPEN_SOURCE 500
+#define _XOPEN_SOURCE   500
+#define LENGTH(X)       (sizeof X / sizeof X[0])
 #if HAVE_SHADOW_H
 #include <shadow.h>
 #endif
@@ -15,9 +16,14 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <X11/extensions/Xrandr.h>
+#ifdef XINERAMA
+#include <X11/extensions/Xinerama.h>
+#endif
 #include <X11/keysym.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
+#include <X11/XKBlib.h>
+#include <Imlib2.h>
 
 #include "arg.h"
 #include "util.h"
@@ -25,17 +31,27 @@
 char *argv0;
 
 enum {
+    BACKGROUND,
 	INIT,
 	INPUT,
 	FAILED,
+	CAPS,
 	NUMCOLS
 };
 
+#include "config.h"
+
 struct lock {
 	int screen;
 	Window root, win;
 	Pixmap pmap;
+	Pixmap bgmap;
 	unsigned long colors[NUMCOLS];
+    unsigned int x, y;
+    unsigned int xoff, yoff, mw, mh;
+    Drawable drawable;
+    GC gc;
+    XRectangle rectangles[LENGTH(rectangles)];
 };
 
 struct xrandr {
@@ -44,7 +60,7 @@
 	int errbase;
 };
 
-#include "config.h"
+Imlib_Image image;
 
 static void
 die(const char *errstr, ...)
@@ -125,21 +141,48 @@
 }
 
 static void
+resizerectangles(struct lock *lock)
+{
+	int i;
+
+	for (i = 0; i < LENGTH(rectangles); i++){
+		lock->rectangles[i].x = (rectangles[i].x * logosize)
+                                + lock->xoff + ((lock->mw) / 2) - (logow / 2 * logosize);
+		lock->rectangles[i].y = (rectangles[i].y * logosize)
+                                + lock->yoff + ((lock->mh) / 2) - (logoh / 2 * logosize);
+		lock->rectangles[i].width = rectangles[i].width * logosize;
+		lock->rectangles[i].height = rectangles[i].height * logosize;
+	}
+}
+
+static void
+drawlogo(Display *dpy, struct lock *lock, int color)
+{
+	XSetForeground(dpy, lock->gc, lock->colors[color]);
+	XFillRectangles(dpy, lock->win, lock->gc, lock->rectangles, LENGTH(rectangles));
+	XSync(dpy, False);
+}
+
+static void
 readpw(Display *dpy, struct xrandr *rr, struct lock **locks, int nscreens,
        const char *hash)
 {
 	XRRScreenChangeNotifyEvent *rre;
 	char buf[32], passwd[256], *inputhash;
-	int num, screen, running, failure, oldc;
-	unsigned int len, color;
+	int caps, num, screen, running, failure, oldc;
+	unsigned int len, color, indicators;
 	KeySym ksym;
 	XEvent ev;
 
 	len = 0;
+	caps = 0;
 	running = 1;
 	failure = 0;
 	oldc = INIT;
 
+	if (!XkbGetIndicatorState(dpy, XkbUseCoreKbd, &indicators))
+		caps = indicators & 1;
+
 	while (running && !XNextEvent(dpy, &ev)) {
 		if (ev.type == KeyPress) {
 			explicit_bzero(&buf, sizeof(buf));
@@ -179,6 +222,9 @@
 				if (len)
 					passwd[--len] = '\0';
 				break;
+			case XK_Caps_Lock:
+				caps = !caps;
+				break;
 			default:
 				if (num && !iscntrl((int)buf[0]) &&
 				    (len + num < sizeof(passwd))) {
@@ -187,13 +233,15 @@
 				}
 				break;
 			}
-			color = len ? INPUT : ((failure || failonclear) ? FAILED : INIT);
+			color = len ? (caps ? CAPS : INPUT) : (failure || failonclear ? FAILED : INIT);
 			if (running && oldc != color) {
 				for (screen = 0; screen < nscreens; screen++) {
-					XSetWindowBackground(dpy,
-					                     locks[screen]->win,
-					                     locks[screen]->colors[color]);
-					XClearWindow(dpy, locks[screen]->win);
+                    if(locks[screen]->bgmap)
+                        XSetWindowBackgroundPixmap(dpy, locks[screen]->win, locks[screen]->bgmap);
+                    else
+                        XSetWindowBackground(dpy, locks[screen]->win, locks[screen]->colors[0]);
+					//XClearWindow(dpy, locks[screen]->win);
+                    drawlogo(dpy, locks[screen], color);
 				}
 				oldc = color;
 			}
@@ -228,6 +276,10 @@
 	XColor color, dummy;
 	XSetWindowAttributes wa;
 	Cursor invisible;
+#ifdef XINERAMA
+	XineramaScreenInfo *info;
+	int n;
+#endif
 
 	if (dpy == NULL || screen < 0 || !(lock = malloc(sizeof(struct lock))))
 		return NULL;
@@ -235,27 +287,61 @@
 	lock->screen = screen;
 	lock->root = RootWindow(dpy, lock->screen);
 
+    if(image) 
+    {
+        lock->bgmap = XCreatePixmap(dpy, lock->root, DisplayWidth(dpy, lock->screen), DisplayHeight(dpy, lock->screen), DefaultDepth(dpy, lock->screen));
+        imlib_context_set_image(image);
+        imlib_context_set_display(dpy);
+        imlib_context_set_visual(DefaultVisual(dpy, lock->screen));
+        imlib_context_set_colormap(DefaultColormap(dpy, lock->screen));
+        imlib_context_set_drawable(lock->bgmap);
+        imlib_render_image_on_drawable(0, 0);
+        imlib_free_image();
+    }
 	for (i = 0; i < NUMCOLS; i++) {
 		XAllocNamedColor(dpy, DefaultColormap(dpy, lock->screen),
 		                 colorname[i], &color, &dummy);
 		lock->colors[i] = color.pixel;
 	}
 
+	lock->x = DisplayWidth(dpy, lock->screen);
+	lock->y = DisplayHeight(dpy, lock->screen);
+#ifdef XINERAMA
+	if ((info = XineramaQueryScreens(dpy, &n))) {
+		lock->xoff = info[0].x_org;
+		lock->yoff = info[0].y_org;
+		lock->mw = info[0].width;
+		lock->mh = info[0].height;
+	} else
+#endif
+	{
+		lock->xoff = lock->yoff = 0;
+		lock->mw = lock->x;
+		lock->mh = lock->y;
+	}
+	lock->drawable = XCreatePixmap(dpy, lock->root,
+            lock->x, lock->y, DefaultDepth(dpy, screen));
+	lock->gc = XCreateGC(dpy, lock->root, 0, NULL);
+	XSetLineAttributes(dpy, lock->gc, 1, LineSolid, CapButt, JoinMiter);
+
 	/* init */
 	wa.override_redirect = 1;
-	wa.background_pixel = lock->colors[INIT];
+	wa.background_pixel = lock->colors[BACKGROUND];
 	lock->win = XCreateWindow(dpy, lock->root, 0, 0,
-	                          DisplayWidth(dpy, lock->screen),
-	                          DisplayHeight(dpy, lock->screen),
+	                          lock->x, lock->y,
 	                          0, DefaultDepth(dpy, lock->screen),
 	                          CopyFromParent,
 	                          DefaultVisual(dpy, lock->screen),
 	                          CWOverrideRedirect | CWBackPixel, &wa);
+    	if(lock->bgmap)
+        	XSetWindowBackgroundPixmap(dpy, lock->win, lock->bgmap);
 	lock->pmap = XCreateBitmapFromData(dpy, lock->win, curs, 8, 8);
 	invisible = XCreatePixmapCursor(dpy, lock->pmap, lock->pmap,
 	                                &color, &color, 0, 0);
 	XDefineCursor(dpy, lock->win, invisible);
 
+	resizerectangles(lock);
+
 	/* Try to grab mouse pointer *and* keyboard for 600ms, else fail the lock */
 	for (i = 0, ptgrab = kbgrab = -1; i < 6; i++) {
 		if (ptgrab != GrabSuccess) {
@@ -276,6 +362,7 @@
 				XRRSelectInput(dpy, lock->win, RRScreenChangeNotifyMask);
 
 			XSelectInput(dpy, lock->root, SubstructureNotifyMask);
+			drawlogo(dpy, lock, INIT);
 			return lock;
 		}
 
@@ -325,13 +412,13 @@
 
 	/* validate drop-user and -group */
 	errno = 0;
-	if (!(pwd = getpwnam(user)))
-		die("slock: getpwnam %s: %s\n", user,
+	if (!(pwd = getpwnam(getenv("USER"))))
+		die("slock: getpwnam %s: %s\n", getenv("USER"),
 		    errno ? strerror(errno) : "user entry not found");
 	duid = pwd->pw_uid;
 	errno = 0;
-	if (!(grp = getgrnam(group)))
-		die("slock: getgrnam %s: %s\n", group,
+	if (!(grp = getgrnam(getenv("USER"))))
+		die("slock: getgrnam %s: %s\n", getenv("USER"),
 		    errno ? strerror(errno) : "group entry not found");
 	dgid = grp->gr_gid;
 
@@ -355,6 +442,60 @@
 	if (setuid(duid) < 0)
 		die("slock: setuid: %s\n", strerror(errno));
 
+	/*Create screenshot Image*/
+	Screen *scr = ScreenOfDisplay(dpy, DefaultScreen(dpy));
+	image = imlib_create_image(scr->width,scr->height);
+	imlib_context_set_image(image);
+	imlib_context_set_display(dpy);
+	imlib_context_set_visual(DefaultVisual(dpy,0));
+	imlib_context_set_drawable(RootWindow(dpy,XScreenNumberOfScreen(scr)));	
+	imlib_copy_drawable_to_image(0,0,0,scr->width,scr->height,0,0,1);
+
+#ifdef BLUR
+
+	/*Blur function*/
+	imlib_image_blur(blurRadius);
+#endif // BLUR	
+
+#ifdef PIXELATION
+	/*Pixelation*/
+	int width = scr->width;
+	int height = scr->height;
+	
+	for(int y = 0; y < height; y += pixelSize)
+	{
+		for(int x = 0; x < width; x += pixelSize)
+		{
+			int red = 0;
+			int green = 0;
+			int blue = 0;
+
+			Imlib_Color pixel; 
+			Imlib_Color* pp;
+			pp = &pixel;
+			for(int j = 0; j < pixelSize && j < height; j++)
+			{
+				for(int i = 0; i < pixelSize && i < width; i++)
+				{
+					imlib_image_query_pixel(x+i,y+j,pp);
+					red += pixel.red;
+					green += pixel.green;
+					blue += pixel.blue;
+				}
+			}
+			red /= (pixelSize*pixelSize);
+			green /= (pixelSize*pixelSize);
+			blue /= (pixelSize*pixelSize);
+			imlib_context_set_color(red,green,blue,pixel.alpha);
+			imlib_image_fill_rectangle(x,y,pixelSize,pixelSize);
+			red = 0;
+			green = 0;
+			blue = 0;
+		}
+	}
+	
+	
+#endif
 	/* check for Xrandr support */
 	rr.active = XRRQueryExtension(dpy, &rr.evbase, &rr.errbase);
 
@@ -391,5 +532,12 @@
 	/* everything is now blank. Wait for the correct password */
 	readpw(dpy, &rr, locks, nscreens, hash);
 
+	for (nlocks = 0, s = 0; s < nscreens; s++) {
+		XFreePixmap(dpy, locks[s]->drawable);
+		XFreeGC(dpy, locks[s]->gc);
+	}
+
+	XSync(dpy, 0);
+	XCloseDisplay(dpy);
 	return 0;
 }
